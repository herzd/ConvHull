#+OPTIONS: ^:nil
* Exact implementation of the convex hull method in Python
  In this file I document my contrib work on the exact version of the convex hull method Python-implementation.  Changes on the initial files (~main.py~, and ~chm_exact.py~) will be produced from this file. The files will be called ~main_v2.py~ and ~chm_exact_v2.py~.
** survey
*** existing code
**** main program (~main.py~)
#+NAME: main.py
#+BEGIN_SRC python :results output :exports none
import chm_exact
reactions = [0, 1]
data_path = "../../DATA/toy/"
chm_exact.compute_CH(data_path + "toy_reactions.txt", data_path + "toy_stoichs.txt", data_path + "toy_domains.txt", reactions)
#+END_SRC

#+RESULTS: main.py
: R1	R2
: 3	3
: 0	-1
: 0	0
: 3	1
: 1	-1

**** library (~chm_exact.py~)
#+NAME: chm_exact.py
#+BEGIN_SRC python :exports none
import sys
import qsoptex
from sympy import Matrix, sympify
from fractions import Fraction

def compute_CH(reactions_path, s_matrix_path, domains_path, impt_reactions):
    """
    Computes the convex hull for production envelopes of metabolic network. Solution is 
    the list of hyperplanes and set of extreme points of the Convex hull. Inputs are:
    ,* fname: name of file without extension (must be the same for all files
      - fname_r.txt: list of reaction names - order must follow that of S columns
      - fname_S.txt: Stoichiometric matrix
      - fname_d.txt : lb ub for each reaction
    ,* impt_reactions: list of indices for the dimensions onto which the CH should be computed
    """
    global RIDS
    global lp_prob

    lp_data = read_problem(reactions_path, s_matrix_path, domains_path)
    obj = [0] * lp_data["Aeq"].shape[1]
    obj[impt_reactions[0]] = 1
    lp_prob = create_lp(lp_data, obj)

    RIDS = lp_data["rids"]


    # INITIAL POINTS
    epts = initial_points(impt_reactions)
   
    # INITIAL HULL
    chull = initial_hull(epts, impt_reactions)

    # INCREMENTAL REFINEMENT
    [chull, epts] = incremental_refinement(chull, epts, impt_reactions)
    print("\t".join([RIDS[d] for d in impt_reactions]))
    for e in range(epts.shape[1]):
        print("\t".join([str(epts[d, e]) for d in impt_reactions]))


def extreme_point(h, h0, optim, dims):
    """
    Computes the extreme point of the projection
    """
    obj = [0] * len(h)
    for i in range(len(dims)):
        obj[dims[i]] = 1

    opt = solve_lp_exact(obj, optim, h, h0)
    return opt


def solve_lp_exact(obj_inds, opt, h_add, h0_add):
    """
    Solves LP exactly
    """
    global RIDS
    global lp_prob

    flag_a = 0
    lp = lp_prob
    # change objective
    new_obj = {}
    # set integers when possible to speed up computation
    for i in range(len(obj_inds)):
        if sympify(obj_inds[i]).is_integer or obj_inds[i] == 0:
            new_obj[RIDS[i]] = int(obj_inds[i])
        elif sympify(obj_inds[i]).is_rational:
            new_obj[RIDS[i]] = Fraction(str(obj_inds[i]))
    lp.set_linear_objective(new_obj)
    # additional constraints other than stoichiometric, if any
    if h_add and h0_add:
        flag_a = 1
        constr = {}
        for j in range(len(h_add)):
            if h_add[j] != 0:
                if sympify(h_add[j]).is_integer:
                    constr[RIDS[j]] = int(h_add[j])
                elif sympify(h_add[i]).is_rational:
                    constr[RIDS[j]] = Fraction(str(h_add[j]))

        lp.add_linear_constraint(qsoptex.ConstraintSense.EQUAL, constr, rhs=Fraction(str(h0_add[0])))

    if opt == -1:
        lp.set_objective_sense(qsoptex.ObjectiveSense.MAXIMIZE)
    elif opt == 1:
        lp.set_objective_sense(qsoptex.ObjectiveSense.MINIMIZE)
    else:
        sys.exit("opt takes 2 possible values: -1 or 1")

    lp.set_param(qsoptex.Parameter.SIMPLEX_DISPLAY, 1)
    status = lp.solve()
    # remove last constraint (if added) from the basis LP
    if flag_a:
        lp.delete_linear_constraint(lp.get_constraint_count() - 1)
    if status == qsoptex.SolutionStatus.OPTIMAL:
        return Matrix(lp.get_values())
    else:
        sys.exit("Solver status is not optimal. Status:" + str(status))


def get_hyperplane(pts, dims):
    """
    Compute the Hessian Normal form of a set of points
    """
    h = Matrix.zeros(1, pts.shape[0])
    dis = -Matrix.ones(pts.shape[1], 1)
    pnts_dims = pts[dims, :].T
    C = pnts_dims.col_insert(pnts_dims.shape[1], dis)
    hess = C.nullspace()
    for i in range(len(dims)):
        h[dims[i]] = hess[0][i]
    h0 = hess[0][-1]
    return [h, h0]


def initial_hull(pnts, dims):
    """
    Computes initial hull for the initial set of extreme points
    """
    hull = []
    for i in range(pnts.shape[1]):
        v = pnts[:, :]
        v.col_del(i)
        [h, h0] = get_hyperplane(v, dims)
        if (h * pnts[:, i])[0] >= h0:
            hull.append([[-h, -h0], v, 1])
        else:
            hull.append([[h, h0], v, 1])
    return hull


def initial_points(dims):
    """
    Computes Initial set of Extreme Points
    """
    global RIDS
    num_vars = len(RIDS)
    h = [0] * num_vars
    h[dims[0]] = 1
    h = Matrix([h])
    # max
    opt = solve_lp_exact(h, -1, [], [])
    hx = h * opt
    eps = extreme_point(h, hx, -1, dims)
    # min
    opt = solve_lp_exact(h, 1, [], [])
    hx = h * opt
    ep = extreme_point(h, hx, 1, dims)
    # if extreme point already in the list of EPs
    if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
        eps = eps.col_insert(eps.shape[1], ep)
    while eps.shape[1] <= len(dims):
        [h, h0] = get_hyperplane(eps, dims)
        opt = solve_lp_exact(h, 1, [], [])
        hx = h * opt
        if hx[0] != h0:
            ep = extreme_point(h, hx, 1, dims)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
        else:
            opt = solve_lp_exact(h, -1, [], [])
            hx = h * opt
            ep = extreme_point(h, hx, -1, dims)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
    return eps


def create_lp(polyt, obj_inds):
    """ Creates core LP problem with the Stoichiometric Matrix and list of constraints"""
    # create problem
    p = qsoptex.ExactProblem()
    [Aeq, beq, rids, domain] = [polyt["Aeq"], polyt["beq"], polyt["rids"], polyt["domain"]]
    [lbs, ubs] = domain
    # add variables to lp
    for i in range(len(rids)):
        p.add_variable(name=rids[i], objective=Fraction(str(obj_inds[i])), lower=lbs[i], upper=ubs[i])
    # constraints
    # for each row in S (metabolite) = for each constraint
    for i in range(Aeq.shape[0]):
        constr = {}
        # for each column in S = for each reaction
        for j in range(Aeq.shape[1]):
            if Aeq[i, j] != 0:
                constr[rids[j]] = int(Aeq[i, j])
        p.add_linear_constraint(qsoptex.ConstraintSense.EQUAL, constr, rhs=int(beq[i]))
    return p


def read_problem(reactions_path, s_matrix_path, domains_path):
    """
    Read LP problem from 3 files: reactions, Stoichiometric matrix, and constraints
    """
    probl = {}
    # read reaction names
    reac_names = []
    infile = open(reactions_path, "r") # fname + "_r.txt"
    for line in infile.readlines():
        line = line.strip()
        reac_names.append(line)
    infile.close()
    probl["rids"] = reac_names
    # read upper and lower bounds of reactions (domain)
    lbs = []
    ubs = []
    infile = open(domains_path, "r") # fname + "_d.txt"
    for line in infile.readlines():
        line = line.strip()
        info = line.split()
        lbs.append(int(info[0]))
        ubs.append(int(info[1]))
    infile.close()
    probl["domain"] = [lbs, ubs]
    # read stoichiometric matrix. Rows=metabolites, columns=reactions
    S = []
    infile = open(s_matrix_path, "r") # fname + "_S.txt"
    for line in infile.readlines():
        line = line.strip()
        row = []
        for col in line.split():
            row.append(int(col))
        S.append(row)
    infile.close()
    beq = [0] * len(S)
    probl["Aeq"] = Matrix(S)
    probl["beq"] = Matrix(beq)

    return probl


def incremental_refinement(chull, eps, dims):
    """
    Refine initial convex hull is refined by maximizing/minimizing the \hps
    containing the \eps until all the facets of the projection are terminal.
    """
    while sum([chull[k][2] for k in range(len(chull))]) != 0:
        for i in range(len(chull)):
            if i >= len(chull):
                break
            h = chull[i][0][0]
            h0 = chull[i][0][1]
            opt = solve_lp_exact(h, -1, [], [])
            hx = h * opt
            if hx[0] == h0:
                chull[i][2] = 0
            else:
                ep = extreme_point(h, hx, -1, dims)
                if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                    eps = eps.col_insert(eps.shape[1], ep)
                    chull = update_CH(ep, eps, chull, dims)
        to_remove = []
        for i in range(len(chull)):
            ec = chull[i][0][0] * eps
            h0 = chull[i][0][1]
            if min(ec) < h0 and max(ec) > h0:
                to_remove.append(i)
        chull = [i for j, i in enumerate(chull) if j not in to_remove]
    return [chull, eps]


def update_CH(new_p, epts, chull, dims):
    """
    Given a new extreme point, compute all possible HP with the new EP
    """
    for i in range(len(chull)):
        pts = chull[i][1]
        if any([pts[dims, p] == new_p[dims, :] for p in range(pts.shape[1])]):
            continue
        bla = chull[i][0][0] * new_p
        if bla[0] <= chull[i][0][1]:
            continue
        for j in range(pts.shape[1]):
            v = pts[:, :]
            v[:, j] = new_p
            [h, h0] = get_hyperplane(v, dims)
            if hp_in_CH(h, h0, v, chull) or hp_in_CH(-h, -h0, v, chull):
                continue
            eh = h * epts
            if max(eh) <= h0:
                chull.append([[h, h0], v, 1])
            else:
                if min(eh) >= h0:
                    chull.append([[-h, -h0], v, 1])
    to_remove = []

    for i in range(len(chull)):
        ec = chull[i][0][0] * epts
        h0 = chull[i][0][1]
        if min(ec) < h0 and max(ec) > h0:
            to_remove.append(i)

    chull = [i for j, i in enumerate(chull) if j not in to_remove]

    return chull


def hp_in_CH(h, h0, v, chull):
    """this function checks if hyperplane and points are already in the CH"""
    flag = 0
    if any([[[h, h0], v] == chull[i][:-1] for i in range(len(chull))]):
        flag = 1
    return flag


# if __name__ == "__main__":
#     filename = sys.argv[1]
#     dims = sys.argv[2]
#     compute_CH(filename, map(int, dims.split(",")))

#+END_SRC
**** library dependency diagram
| Functions              | sympy | qsoptex | solve_lp_exact | get_hyperplane | extreme_point | update_CH | create_lp | read_problem | incremental_refinement | initial_points | initial_hull | hp_in_CH | compute_CH |
|------------------------+-------+---------+----------------+----------------+---------------+-----------+-----------+--------------+------------------------+----------------+--------------+----------+------------|
| sympy                  | X     |         |                |                |               |           |           |              |                        |                |              |          |            |
| qsoptex                |       | X       |                |                |               |           |           |              |                        |                |              |          |            |
| solve_lp_exact         | X     | X       | X              |                |               |           |           |              |                        |                |              |          |            |
| get_hyperplane         | X     |         |                | X              |               |           |           |              |                        |                |              |          |            |
| create_lp              | X     | X       |                |                |               |           | X         |              |                        |                |              |          |            |
| read_problem           | X     |         |                |                |               |           |           | X            |                        |                |              |          |            |
| hp_in_CH               |       |         |                |                |               |           |           |              |                        |                |              | X        |            |
| update_CH              | X     |         |                | X              |               | X         |           |              |                        |                |              |          |            |
| compute_CH             | X     | X       | X              | X              | X             | X         | X         | X            | X                      | X              | X            |          | X          |
| incremental_refinement | X     | X       | X              | X              | X             | X         |           |              | X                      |                |              |          |            |
| initial_points         | X     | X       | X              |                | X             |           |           |              |                        | X              |              |          |            |
| extreme_point          | X     | X       | X              |                | X             |           |           |              |                        |                |              |          |            |
| initial_hull           | X     |         |                |                |               |           |           |              |                        |                | X            |          |            |

** workon
*** TODO structural library analysis for speed tuning
    The 'main' program is now integrated into the 'library' for a more compact design. It can be run with ~python3 chm_exact_v2.py -m ../../DATA/toy/iToy.xml 2~ and yields the same results as the original one. 
**** independent functions
     The following functions partly depend on sympy and qsoptex, but do not depend on each other. 
***** shebang and docstring
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py" :shebang "#!/usr/bin/env python3"
""" library of functions for the exact convhull python algorithm"""
      #+END_SRC
***** dependencies
      #+begin_src python :tangle "./chm_exact_v2.py"
import argparse
import fractions
import gzip
import os
import sys
import urllib
import xml.etree.ElementTree
import qsoptex
import sympy
      #+end_src
***** download_model
      Function to retrieve model from the web.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def download_model(url):
    '''downloads existing model from the web, url has to be a string.
    returns absolute path of downloaded file as string.'''
    filename = url.split("/")[-1:][0]
    filepath = os.path.abspath(filename)
    with urllib.request.urlopen(url) as traveller:
        with open(filepath,"wb") as destination:
            destination.write(traveller.read())
    return filepath
      #+END_SRC
***** parse_xml_model
      Function to parse downloaded xml-model and create xml.etree.ElementTree object for further processing.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def parse_xml_model(model):
    '''parses existing xml model, given path as string.
    if gunzipped and ends with the extension .gz, unzips the file.
    returns xml.etree.ElementTree object root.'''
    if model.endswith("gz"):
        with gzip.open(model) as unpacked:
            tree = xml.etree.ElementTree.parse(unpacked)
            root = tree.getroot()
    else:
        tree = xml.etree.ElementTree.parse(model)
        root = tree.getroot()
    return root
      #+END_SRC
***** extract_metabolites
      Function to extract all metabolites from model and return them as list of tuples containing name and ID.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def extract_metabolites(model):
    '''takes a parsed model in xml.etree.ElementTree.parse-getroot format and returns
    a list of the ids of the metabolites stored in the model.'''
    metabolites_model = model.findall("{http://www.sbml.org/sbml/level3/version1/core}model/"
                                      "{http://www.sbml.org/sbml/level3/version1/core}listOfSpecies/"
                                      "{http://www.sbml.org/sbml/level3/version1/core}species")
    metabolite_list = [metabolite.attrib["id"]
                       for metabolite in metabolites_model]
    return metabolite_list
      #+END_SRC
***** extract_stoichiometry
      Function to extract the stoichiometric information from model, return it as list of tuples
      containing reaction name and the inversed stoichiometric value as int.
      #+begin_src python :tangle "./chm_exact_v2.py"
def extract_stoichiometry(model):
    '''takes a parsed model in xml.etree.ElementTree.parse-getroot format and returns
    a list of tuples containing reaction-name and the negative stoichiometric value as int'''
    # make sure that we match the item we want to process
    stoichiometric_list = []
    reaction_list = model.findall("{http://www.sbml.org/sbml/level3/version1/core}model/"
                                  "{http://www.sbml.org/sbml/level3/version1/core}listOfReactions/")
    for reaction in reaction_list:
        for child in reaction[0]:
            if "listOfProducts" in str(reaction[0]):
                stoichiometric_list.append((reaction.attrib['name'],
                                           child.attrib['species'],
                                           float(child.attrib['stoichiometry'])))
            elif "listOfReactants" in str(reaction[0]):
                stoichiometric_list.append((reaction.attrib['name'],
                                           child.attrib['species'],
                                           -1*float(child.attrib['stoichiometry'])))
    return stoichiometric_list
      #+end_src
***** extract_parameters
      Function to extract all parameters from model and return them as list of tuples containing id and value.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def extract_parameters(model):
    '''takes a parsed model in xml.etree.ElementTree.parse-getroot format and returns
    a list of tuples containing id and value of the given parameters.'''
    parameters_model = model.findall("{http://www.sbml.org/sbml/level3/version1/core}model/"
                                     "{http://www.sbml.org/sbml/level3/version1/core}listOfParameters/"
                                     "{http://www.sbml.org/sbml/level3/version1/core}parameter")
    parameter_list = [(parameter.attrib["id"],
                       parameter.attrib["value"])
                      for parameter in parameters_model]
    return parameter_list
      #+END_SRC
***** extract_reactions
      Function to extract reactions and according boundaries.
      #+begin_src python :tangle "./chm_exact_v2.py"
def extract_reactions(model):
    '''takes a parsed model in xml.etree.ElementTree.parse-getroot format and returns
    a list of tuples containing reaction-name, lower bound, and upper bound'''
    # the following two definitions are just here to keep the linelength in range
    fbc_lb_string = "{http://www.sbml.org/sbml/level3/version1/fbc/version2}lowerFluxBound"
    fbc_ub_string = "{http://www.sbml.org/sbml/level3/version1/fbc/version2}upperFluxBound"
    reactions_model = model.findall("{http://www.sbml.org/sbml/level3/version1/core}model/"
                                    "{http://www.sbml.org/sbml/level3/version1/core}listOfReactions/"
                                    "{http://www.sbml.org/sbml/level3/version1/core}reaction")
    reaction_list = [(reaction.attrib["name"],
                      reaction.attrib[fbc_lb_string],
                      reaction.attrib[fbc_ub_string])
                     for reaction in reactions_model]
    return reaction_list
      #+end_src
***** resolve_parameters
      Function to resolve lower and upper fluxbounds to actual numbers.
      #+begin_src python :tangle "./chm_exact_v2.py"
def resolve_parameters(reaction_list, parameters):
    '''takes the list of reactions containing the unresolved (simply named) parameters
    and replaces them by the actual values from the parameters list (second argument).
    returns the reaction list with filled integer values for bounds .'''
    updated_reaction_list = []
    for reaction in reaction_list:
        for parameter in parameters:
            if reaction[1] == parameter[0]:
                lower_bound_int = int(parameter[1])
            elif reaction[2] == parameter[0]:
                upper_bound_int = int(parameter[1])
        updated_reaction_list.append((reaction[0],
                                      lower_bound_int,
                                      upper_bound_int))
    return updated_reaction_list
    #+end_src
***** TODO solve_lp_exact
      + inputs (object-type) :: obj_inds (list), opt (?), h_add (?), h0_add (?)
      + outputs(object-type) :: Matrix(lp.get_values()) (sympy matrix)
      + depends (packages) :: sympy, qsoptex
      #+begin_src python :tangle "./chm_exact_v2.py"
def solve_lp_exact(obj_inds, opt, h_add, h0_add, reaction_ids, lp_prob):
    """
    Solves LP exactly
    """
    flag_a = 0
    # change objective
    new_obj = {}
    # set integers when possible to speed up computation
    for pos, value in enumerate(obj_inds):
        if sympy.sympify(obj_inds[pos]).is_integer or obj_inds[pos] == 0:
            new_obj[reaction_ids[pos]] = int(obj_inds[pos])
        elif sympy.sympify(obj_inds[pos]).is_rational:
            new_obj[reaction_ids[pos]] = fractions.Fraction(str(obj_inds[pos]))
    lp_prob.set_linear_objective(new_obj)
    # additional constraints other than stoichiometric, if any
    if h_add and h0_add:
        flag_a = 1
        constr = {}
        for pos,value in enumerate(h_add):
            if h_add[pos] != 0:
                if sympy.sympify(h_add[pos]).is_integer:
                    constr[reaction_ids[pos]] = int(h_add[pos])
                elif sympy.sympify(h_add[pos]).is_rational:
                    constr[reaction_ids[pos]] = fractions.Fraction(str(h_add[pos]))
        lp_prob.add_linear_constraint(qsoptex.ConstraintSense.EQUAL,
                                      constr,
                                      rhs=fractions.Fraction(str(h0_add[0])))
    if opt == -1:
        lp_prob.set_objective_sense(qsoptex.ObjectiveSense.MAXIMIZE)
    elif opt == 1:
        lp_prob.set_objective_sense(qsoptex.ObjectiveSense.MINIMIZE)
    else:
        sys.exit("opt takes 2 possible values: -1 or 1")
    lp_prob.set_param(qsoptex.Parameter.SIMPLEX_DISPLAY, 1)
    status = lp_prob.solve()
    # remove last constraint (if added) from the basis LP_PROB
    if flag_a:
        lp_prob.delete_linear_constraint(lp_prob.get_constraint_count() - 1)
    if status == qsoptex.SolutionStatus.OPTIMAL:
        return sympy.Matrix(lp_prob.get_values())
    else:
        sys.exit("Solver status is not optimal. Status:" + str(status))

       #+end_src
***** TODO get_hyperplane
      + inputs (object-type) :: pts (?), dims (?)
      + outputs (object-type) :: h(?), h0 (?)
      + depends (packages) :: sympy
      #+begin_src python :tangle "./chm_exact_v2.py"
def get_hyperplane(pts, dims):
    """
    Compute the Hessian Normal form of a set of points
    """
    h = sympy.Matrix.zeros(1, pts.shape[0])
    dis = -sympy.Matrix.ones(pts.shape[1], 1)
    pnts_dims = pts[dims, :].T
    C = pnts_dims.col_insert(pnts_dims.shape[1], dis)
    hess = C.nullspace()
    for i in range(len(dims)):
        h[dims[i]] = hess[0][i]
    h0 = hess[0][-1]
    return [h, h0]
      #+end_src
***** read_problem
      + inputs (object-type) :: reactions_path (textfile), s_matrix_path (textfile), domains_path (textfile)
      + outputs (object-type) :: probl (dict)
      + depends (packages) :: sympy
      #+begin_src python :tangle "./chm_exact_v2.py"
def read_problem(reactions_file, stoichiometrics_file, domains_file):
    """
    Read LP problem from 3 files: reactions, Stoichiometric matrix, and constraints
    """
    problem = {}
    # read reaction names
    reac_names = []
    with open(reactions_file, "r") as file_to_read:
        for line in file_to_read.readlines():
            line = line.strip()
            reac_names.append(line)
    problem["rids"] = reac_names
    # read upper and lower bounds of reactions (domain)
    lower_bounds = []
    upper_bounds = []
    with open(domains_file, "r") as file_to_read:
        for line in file_to_read.readlines():
            info = line.strip()
            info = line.split()
            lower_bounds.append(int(info[0]))
            upper_bounds.append(int(info[1]))
    problem["domain"] = [lower_bounds, upper_bounds]
    # read stoichiometric matrix. Rows=metabolites, columns=reactions
    S = []
    with open(stoichiometrics_file, "r") as file_to_read:
        for line in file_to_read.readlines():
            line = line.strip()
            row = []
            for column in line.split():
                row.append(int(column))
            S.append(row)
    beq = [0] * len(S)
    problem["Aeq"] = sympy.Matrix(S)
    problem["beq"] = sympy.Matrix(beq)
    return problem
      #+end_src
***** TODO create_lp
      + inputs (object-type) :: polyt (?), obj_inds (?)
      + outputs (object-type) :: p (?)
      + depends (packages) :: qsoptex, sympy
      #+begin_src python :tangle "./chm_exact_v2.py"
def create_lp(polyt, obj_inds):
    """ Creates core LP problem with the Stoichiometric Matrix and list of constraints"""
    # create problem
    problem = qsoptex.ExactProblem()
    Aeq,beq,rids = polyt["Aeq"], polyt["beq"], polyt["rids"]
    lower_bound,upper_bound = polyt["domain"]
    # add variables to linear problem
    for i in range(len(rids)):
        problem.add_variable(name=rids[i],
                             objective=fractions.Fraction(str(obj_inds[i])),
                             lower=lower_bound[i],
                             upper=upper_bound[i])
    # constraints
    # for each row in S (metabolite) = for each constraint
    for i in range(Aeq.shape[0]):
        constr = {}
        # for each column in S = for each reaction
        for j in range(Aeq.shape[1]):
            if Aeq[i, j] != 0:
                constr[rids[j]] = int(Aeq[i, j])
        problem.add_linear_constraint(qsoptex.ConstraintSense.EQUAL, constr, rhs=int(beq[i]))
    return problem
      #+end_src
***** TODO hp_in_chull
      + inputs (object-type) :: h (?), h0 (?), v (?), chull (?)
      + outputs (object-type) :: flag (?)
      #+begin_src python :tangle "./chm_exact_v2.py"
def hp_in_chull(h, h0, v, chull):
    """this function checks if hyperplane and points are already in the CH"""
    flag = 0
    if any([[[h, h0], v] == chull[i][:-1] for i in range(len(chull))]):
        flag = 1
    return flag
      #+end_src
**** interdependent functions
     These functions partly depend on each other and/or the functions above.
***** TODO update_chull
      + inputs (object-type)  :: new_p (?), epts (?), chull (?), dims (?)
      + outputs (object-type) :: chull (?)
      + depends (return_object/return object type/self-depends) :: get_hyperplane(h,h0/??/sympy)
      #+begin_src python :tangle "./chm_exact_v2.py"
def update_chull(new_p, epts, chull, dims):
    """
    Given a new extreme point, compute all possible HP with the new EP
    """
    for i in range(len(chull)):
        pts = chull[i][1]
        if any([pts[dims, p] == new_p[dims, :] for p in range(pts.shape[1])]):
            continue
        bla = chull[i][0][0] * new_p
        if bla[0] <= chull[i][0][1]:
            continue
        for j in range(pts.shape[1]):
            v = pts[:, :]
            v[:, j] = new_p
            [h, h0] = get_hyperplane(v, dims)
            if hp_in_chull(h, h0, v, chull) or hp_in_chull(-h, -h0, v, chull):
                continue
            eh = h * epts
            if max(eh) <= h0:
                chull.append([[h, h0], v, 1])
            else:
                if min(eh) >= h0:
                    chull.append([[-h, -h0], v, 1])
    to_remove = []
    for i in range(len(chull)):
        ec = chull[i][0][0] * epts
        h0 = chull[i][0][1]
        if min(ec) < h0 and max(ec) > h0:
            to_remove.append(i)
    chull = [i for j, i in enumerate(chull) if j not in to_remove]
    return chull
      #+end_src

***** TODO compute_chull
      + inputs (object-type) :: reactions_path (textfile), s_matrix_path (textfile), domains_path (textfile), impt_reactions (list)
      + outputs (object-type) :: chull (dict), epts (sympy.Matrix)
      + depends (return object/return object type/self-depends) :: read_problem (probl/dict), create_lp (p/), initial_points (eps/sympy.Matrix/solve_lp_exact, extreme_point),initial_hull (hull/?/get_hyperplane), incremental_refinement (chull, eps/??/solve_lp_exact, extreme_points, update_chull)
      #+begin_src python :tangle "./chm_exact_v2.py" 
def compute_chull(lp_data, impt_reactions, reaction_ids, lp_prob):
    """
    Computes the convex hull for production envelopes of metabolic network. Solution is
    the list of hyperplanes and set of extreme points of the Convex hull. Inputs are:
      - lp_data: dictionary containing the keys 'rids', 'Aeq', 'beq'
      - fname_r.txt: list of reaction names - order must follow that of S columns
      - fname_S.txt: Stoichiometric matrix
      - fname_d.txt : lb ub for each reaction
    ,* impt_reactions: list of indices for the dimensions onto which the CH should be computed
    """
    # INITIAL POINTS
    epts = initial_points(impt_reactions, reaction_ids,lp_prob)
    # INITIAL HULL
    chull = initial_hull(epts, impt_reactions)
    return chull,epts
      #+end_src
***** TODO incremental_refinement
      + inputs (object-type) :: chull (dictionary), eps (?), dims (?)
      + outputs (object-type) :: chull (?), eps (?)
      + depends (return object/return object type/self-depends) :: solve_lp_exact (Matrix(lp.get_values())/sympy matrix/qsoptex,sympy), extreme_point (opt/?/solve_lp_exact), update_chull (chull/?/get_hyperplane)
      #+begin_src python :tangle "./chm_exact_v2.py"
def incremental_refinement(chull, eps, dims, reaction_ids, lp_prob):
    """
    Refine initial convex hull is refined by maximizing/minimizing the hps
    containing the eps until all the facets of the projection are terminal.
    """
    while sum([chull[k][2] for k in range(len(chull))]) != 0:
        for i in range(len(chull)):
            if i >= len(chull):
                break
            h = chull[i][0][0]
            h0 = chull[i][0][1]
            opt = solve_lp_exact(h, -1, [], [], reaction_ids, lp_prob)
            hx = h * opt
            if hx[0] == h0:
                chull[i][2] = 0
            else:
                ep = extreme_point(h, hx, -1, dims, reaction_ids, lp_prob)
                if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                    eps = eps.col_insert(eps.shape[1], ep)
                    chull = update_chull(ep, eps, chull, dims)
        to_remove = []
        for i in range(len(chull)):
            ec = chull[i][0][0] * eps
            h0 = chull[i][0][1]
            if min(ec) < h0 and max(ec) > h0:
                to_remove.append(i)
        chull = [i for j, i in enumerate(chull) if j not in to_remove]
    return chull, eps
      #+end_src
***** TODO initial_points
      + inputs (object-type) :: dims
      + outputs (object-type) :: eps
      + depends (return object/return object type/self-depends) :: solve_lp_exact (Matrix(lp.get_values())/sympy matrix/qsoptex,sympy), extreme_point (opt/?/solve_lp_exact)
      #+begin_src python :tangle "./chm_exact_v2.py"
def initial_points(dims,reaction_ids, lp_prob): # depends on solve_lp_exact and extreme_point
    """
    Computes Initial set of Extreme Points
    """
    h = [0] * len(reaction_ids)
    h[dims[0]] = 1
    h = sympy.Matrix([h])
    # max
    opt = solve_lp_exact(h, -1, [], [], reaction_ids, lp_prob)
    hx = h * opt
    eps = extreme_point(h, hx, -1, dims, reaction_ids, lp_prob)
    # min
    opt = solve_lp_exact(h, 1, [], [], reaction_ids, lp_prob)
    hx = h * opt
    ep = extreme_point(h, hx, 1, dims, reaction_ids, lp_prob)
    # if extreme point already in the list of EPs
    if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
        eps = eps.col_insert(eps.shape[1], ep)
    while eps.shape[1] <= len(dims):
        [h, h0] = get_hyperplane(eps, dims)
        opt = solve_lp_exact(h, 1, [], [], reaction_ids, lp_prob)
        hx = h * opt
        if hx[0] != h0:
            ep = extreme_point(h, hx, 1, dims, reaction_ids, lp_prob)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
        else:
            opt = solve_lp_exact(h, -1, [], [])
            hx = h * opt
            ep = extreme_point(h, hx, -1, dims, reaction_ids, lp_prob)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
    return eps
      #+end_src
***** TODO extreme_point
      + inputs (object-type) :: h (?) , h0 (?), optim (?), dims (?)
      + outputs (object-type) :: opt (?)
      + depends (return object/return object type/self-depends) :: solve_lp_exact (Matrix(lp.get_values())/sympy matrix/qsoptex,sympy)
      #+begin_src python :tangle "./chm_exact_v2.py"
def extreme_point(h, h0, optim, dims, reaction_ids, lp_prob): # depends on solve_lp_exact
    """
    Computes the extreme point of the projection
    """
    obj = [0] * len(h)
    for i in range(len(dims)):
        obj[dims[i]] = 1
    opt = solve_lp_exact(obj, optim, h, h0, reaction_ids, lp_prob)
    return opt
      #+end_src
***** TODO initial_hull
      + inputs (object-type) :: pnts (?), dims (?)
      + outputs (object-type) :: hull (?)
      + depends (return object/return object type/self-depends) :: get_hyperplane (h,h0/??/sympy)
      #+begin_src python :tangle "./chm_exact_v2.py"
def initial_hull(pnts, dims): # depends on get_hyperplane
    """
    Computes initial hull for the initial set of extreme points
    """
    hull = []
    for i in range(pnts.shape[1]):
        v = pnts[:, :]
        v.col_del(i)
        [h, h0] = get_hyperplane(v, dims)
        if (h * pnts[:, i])[0] >= h0:
            hull.append([[-h, -h0], v, 1])
        else:
            hull.append([[h, h0], v, 1])
    return hull
      #+end_src
***** TODO main
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def main():
    """
    main procedure using functions from above. the program either takes an URL to a
    downloadable xml(sbml) model, or a filepath to one.  Models may be gzipped.
    If no whole model is available neither online or offline, one can also feed
    the program with three separate files:
    - reaction_file: absolute path to file with one reaction name string in each line.
    - stoichiometric_file: absolute path to file with stoichiometric values for the reactions.
    - boundary_file: absolute path to file with lower and upper bounds for each reaction.
    A dimensionality has to be given as int, to define onto how many dimensions the result
    should be projected.
    This function does not return any object.
    The list of hyperplanes and set of the hull's extreme points of the hull are printed to stdout.
    """
    # argument parser for easier operations with the program
    parser = argparse.ArgumentParser(description='Calculate projected convex set of given network. \
Needs either an xml/sbml-model or 3 files containing the relevant data.')
    parser.add_argument("dimensionality", type = int,
                        help="dimension N onto which convhull shall be projected.")
    parser.add_argument("-m", "--model_location", type=str,
                        help="weburl pointing to sbml(xml)-model, can be a filepath too.")
    parser.add_argument("-r", "--reaction_file", type=str,
                        help="path to file containing reaction ids line by line.")
    parser.add_argument("-s", "--stoichiometric_file", type=str,
                        help="path to file containing stoichiometrics of reactions.")
    parser.add_argument("-b", "--boundary_file", type=str,
                        help="path to file containing upper and lower bounds.")
    arguments = parser.parse_args()
    if arguments.model_location:
        if arguments.model_location.startswith("http"):
            model_path = download_model(arguments.model_location)
            print("downloaded model to:\n\{}\n".format(model_path))
        else:
            model_path = arguments.model_location
            print("loaded model:\n{}\n".format(model_path))
        parsed_model = parse_xml_model(model_path)
        stoichiometry = extract_stoichiometry(parsed_model)
        parameters = extract_parameters(parsed_model)
        reactions = extract_reactions(parsed_model)
        reactions_with_bounds = resolve_parameters(reactions,parameters)
        input_reactions = list(range(arguments.dimensionality))
#        this one here would already deliver all needed information for the calculation
#        print(stoichiometry,reactions_with_bounds)
        # what's happening here dirtily is done to keep structural compatibility with the
        # initial version of the algorithm that still sits in this code. this
        # will be rearranged, once that one is standardized. this will have to be done,
        # as for now it forces to destroy the node-hierarchy of sbml. we are actively
	# losing structural information from the model. The goal is to rearrange
	# the 'polytope = dictionary = problem_read' to hold all the information
	# by reactions. This is technically easy, but the create_lp-function
	# relies on this intermingled dictionary for now.
        read_problem_init = dict.fromkeys(["rids","domain","Aeq","beq"])
        read_problem_init["rids"] = [entry[0] for entry in stoichiometry]
        lower_bounds = [entry[1] for entry in reactions_with_bounds]
        upper_bounds = [entry[2] for entry in reactions_with_bounds]
        read_problem_init["domain"] = [lower_bounds,upper_bounds]
        read_problem_init["Aeq"] = sympy.Matrix([[entry[2] for entry in stoichiometry]])
        read_problem_init["beq"] = sympy.Matrix([0]*len([[entry[2] for entry in stoichiometry]]))
        problem_read = read_problem_init
    else:
#       this here reads the information from files (that most likely derive from
#       a given model).
        reaction_file = arguments.reaction_file
        stoichiometric_file = arguments.stoichiometric_file
        boundary_file = arguments.boundary_file
        problem_read = read_problem(reaction_file,
                                    stoichiometric_file,
                                    boundary_file)
    print("\ninitital problem:\n{}\n".format(problem_read))
    print("projecting hull onto {} dimensions.\n".format(arguments.dimensionality))
    input_reactions = list(range(arguments.dimensionality))
    # create for qsopt_ex (with the toy data this makes a list of 3 zeros)
    objective = [0] * problem_read["Aeq"].shape[1]
    # this sets the first zero to 1
    objective[input_reactions[0]] = 1
    # create linear problem from the dictionary to get rid off global statements within functions
    problem_created = create_lp(problem_read,
                                objective)
    print("created linear problem with qsopt_ex.\n")
    # extract reaction ids, to get rid off the global statements within functions
    reaction_ids = problem_read["rids"]
    chull, epts = compute_chull(problem_read,
                                input_reactions,
                                reaction_ids,
                                problem_created)
    # refine results
    refined_chull, refined_epts = incremental_refinement(chull,
                                                         epts,
                                                         input_reactions,
                                                         reaction_ids,
                                                         problem_created)
    print("refined convex hull:\n{}\n".format(refined_chull))
    print("refined set of points:\n{}\n".format(refined_epts))
      #+END_SRC
**** syntax sugar for proper wrapping
     #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
if __name__ == "__main__":
    main()
     #+END_SRC
**** run it
***** show help
      #+NAME: show-help
      #+BEGIN_SRC shell :results output :exports both
./chm_exact_v2.py -h     
      #+END_SRC

      #+RESULTS: show-help
      #+begin_example
      usage: chm_exact_v2.py [-h] [-m MODEL_LOCATION] [-r REACTION_FILE]
			     [-s STOICHIOMETRIC_FILE] [-b BOUNDARY_FILE]
			     dimensionality

      Calculate projected convex set of given network. Needs either an xml/sbml-
      model or 3 files containing the relevant data.

      positional arguments:
	dimensionality        dimension N onto which convhull shall be projected.

      optional arguments:
	-h, --help            show this help message and exit
	-m MODEL_LOCATION, --model_location MODEL_LOCATION
			      weburl pointing to sbml(xml)-model, can be a filepath
			      too.
	-r REACTION_FILE, --reaction_file REACTION_FILE
			      path to file containing reaction ids line by line.
	-s STOICHIOMETRIC_FILE, --stoichiometric_file STOICHIOMETRIC_FILE
			      path to file containing stoichiometrics of reactions.
	-b BOUNDARY_FILE, --boundary_file BOUNDARY_FILE
			      path to file containing upper and lower bounds.
      #+end_example
***** run with xml
      #+BEGIN_SRC shell :results output :exports both
./chm_exact_v2.py -m ../../DATA/toy/iToy.xml \
		  2
      #+END_SRC

      #+RESULTS:
      #+begin_example
      loaded model:
      ../../DATA/toy/iToy.xml


      initital problem:
      {'rids': ['R1', 'R2', 'R3'], 'domain': [[0, -1, 0], [3, 1000, 2]], 'Aeq': Matrix([[1, -1, -1]]), 'beq': Matrix([[0]])}

      projecting hull onto 2 dimensions.

      created linear problem with qsopt_ex.

      refined convex hull:
      [[[Matrix([[-1, 0, 0]]), 0], Matrix([
      [ 0, 0],
      [-1, 0],
      [ 1, 0]]), 0], [[Matrix([[-1, 1, 0]]), 0], Matrix([
      [3, 0],
      [3, 0],
      [0, 0]]), 0], [[Matrix([[1/3, 0, 0]]), 1], Matrix([
      [3, 3],
      [3, 1],
      [0, 2]]), 0], [[Matrix([[0, -1, 0]]), 1], Matrix([
      [ 1,  0],
      [-1, -1],
      [ 2,  1]]), 0], [[Matrix([[1/2, -1/2, 0]]), 1], Matrix([
      [3,  1],
      [1, -1],
      [2,  2]]), 0]]

      refined set of points:
      Matrix([[3, 0, 0, 3, 1], [3, -1, 0, 1, -1], [0, 1, 0, 2, 2]])

      #+end_example
***** run from separate files
      #+BEGIN_SRC shell :results output :exports both
./chm_exact_v2.py -r ../../DATA/toy/toy_reactions.txt \
		  -s ../../DATA/toy/toy_stoichs.txt \
		  -b ../../DATA/toy/toy_domains.txt \
		  2
      #+END_SRC

      #+RESULTS:
      #+begin_example

      initital problem:
      {'rids': ['R1', 'R2', 'R3'], 'domain': [[0, -1, 0], [3, 1000, 2]], 'Aeq': Matrix([[1, -1, -1]]), 'beq': Matrix([[0]])}

      projecting hull onto 2 dimensions.

      created linear problem with qsopt_ex.

      refined convex hull:
      [[[Matrix([[-1, 0, 0]]), 0], Matrix([
      [ 0, 0],
      [-1, 0],
      [ 1, 0]]), 0], [[Matrix([[-1, 1, 0]]), 0], Matrix([
      [3, 0],
      [3, 0],
      [0, 0]]), 0], [[Matrix([[1/3, 0, 0]]), 1], Matrix([
      [3, 3],
      [3, 1],
      [0, 2]]), 0], [[Matrix([[0, -1, 0]]), 1], Matrix([
      [ 1,  0],
      [-1, -1],
      [ 2,  1]]), 0], [[Matrix([[1/2, -1/2, 0]]), 1], Matrix([
      [3,  1],
      [1, -1],
      [2,  2]]), 0]]

      refined set of points:
      Matrix([[3, 0, 0, 3, 1], [3, -1, 0, 1, -1], [0, 1, 0, 2, 2]])

      #+end_example
