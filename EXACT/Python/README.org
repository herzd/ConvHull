#+OPTIONS: ^:nil
* Exact implementation of the convex hull method in Python
  In this file I document my contrib work on the exact version of the convex hull method Python-implementation.  Changes on the initial files (~main.py~, and ~chm_exact.py~) will be produced from this file. The files will be called ~main_v2.py~ and ~chm_exact_v2.py~.
** survey
*** existing code
**** main program (~main.py~)
#+NAME: main.py
#+BEGIN_SRC python :results output :exports none
import chm_exact
reactions = [0, 1]
data_path = "../../DATA/toy/"
chm_exact.compute_CH(data_path + "toy_reactions.txt", data_path + "toy_stoichs.txt", data_path + "toy_domains.txt", reactions)
#+END_SRC

#+RESULTS: main.py
: R1	R2
: 3	3
: 0	-1
: 0	0
: 3	1
: 1	-1

**** library (~chm_exact.py~)
#+NAME: chm_exact.py
#+BEGIN_SRC python :exports none
import sys
import qsoptex
from sympy import Matrix, sympify
from fractions import Fraction

def compute_CH(reactions_path, s_matrix_path, domains_path, impt_reactions):
    """
    Computes the convex hull for production envelopes of metabolic network. Solution is 
    the list of hyperplanes and set of extreme points of the Convex hull. Inputs are:
    ,* fname: name of file without extension (must be the same for all files
      - fname_r.txt: list of reaction names - order must follow that of S columns
      - fname_S.txt: Stoichiometric matrix
      - fname_d.txt : lb ub for each reaction
    ,* impt_reactions: list of indices for the dimensions onto which the CH should be computed
    """
    global RIDS
    global lp_prob

    lp_data = read_problem(reactions_path, s_matrix_path, domains_path)
    obj = [0] * lp_data["Aeq"].shape[1]
    obj[impt_reactions[0]] = 1
    lp_prob = create_lp(lp_data, obj)

    RIDS = lp_data["rids"]


    # INITIAL POINTS
    epts = initial_points(impt_reactions)
   
    # INITIAL HULL
    chull = initial_hull(epts, impt_reactions)

    # INCREMENTAL REFINEMENT
    [chull, epts] = incremental_refinement(chull, epts, impt_reactions)
    print("\t".join([RIDS[d] for d in impt_reactions]))
    for e in range(epts.shape[1]):
        print("\t".join([str(epts[d, e]) for d in impt_reactions]))


def extreme_point(h, h0, optim, dims):
    """
    Computes the extreme point of the projection
    """
    obj = [0] * len(h)
    for i in range(len(dims)):
        obj[dims[i]] = 1

    opt = solve_lp_exact(obj, optim, h, h0)
    return opt


def solve_lp_exact(obj_inds, opt, h_add, h0_add):
    """
    Solves LP exactly
    """
    global RIDS
    global lp_prob

    flag_a = 0
    lp = lp_prob
    # change objective
    new_obj = {}
    # set integers when possible to speed up computation
    for i in range(len(obj_inds)):
        if sympify(obj_inds[i]).is_integer or obj_inds[i] == 0:
            new_obj[RIDS[i]] = int(obj_inds[i])
        elif sympify(obj_inds[i]).is_rational:
            new_obj[RIDS[i]] = Fraction(str(obj_inds[i]))
    lp.set_linear_objective(new_obj)
    # additional constraints other than stoichiometric, if any
    if h_add and h0_add:
        flag_a = 1
        constr = {}
        for j in range(len(h_add)):
            if h_add[j] != 0:
                if sympify(h_add[j]).is_integer:
                    constr[RIDS[j]] = int(h_add[j])
                elif sympify(h_add[i]).is_rational:
                    constr[RIDS[j]] = Fraction(str(h_add[j]))

        lp.add_linear_constraint(qsoptex.ConstraintSense.EQUAL, constr, rhs=Fraction(str(h0_add[0])))

    if opt == -1:
        lp.set_objective_sense(qsoptex.ObjectiveSense.MAXIMIZE)
    elif opt == 1:
        lp.set_objective_sense(qsoptex.ObjectiveSense.MINIMIZE)
    else:
        sys.exit("opt takes 2 possible values: -1 or 1")

    lp.set_param(qsoptex.Parameter.SIMPLEX_DISPLAY, 1)
    status = lp.solve()
    # remove last constraint (if added) from the basis LP
    if flag_a:
        lp.delete_linear_constraint(lp.get_constraint_count() - 1)
    if status == qsoptex.SolutionStatus.OPTIMAL:
        return Matrix(lp.get_values())
    else:
        sys.exit("Solver status is not optimal. Status:" + str(status))


def get_hyperplane(pts, dims):
    """
    Compute the Hessian Normal form of a set of points
    """
    h = Matrix.zeros(1, pts.shape[0])
    dis = -Matrix.ones(pts.shape[1], 1)
    pnts_dims = pts[dims, :].T
    C = pnts_dims.col_insert(pnts_dims.shape[1], dis)
    hess = C.nullspace()
    for i in range(len(dims)):
        h[dims[i]] = hess[0][i]
    h0 = hess[0][-1]
    return [h, h0]


def initial_hull(pnts, dims):
    """
    Computes initial hull for the initial set of extreme points
    """
    hull = []
    for i in range(pnts.shape[1]):
        v = pnts[:, :]
        v.col_del(i)
        [h, h0] = get_hyperplane(v, dims)
        if (h * pnts[:, i])[0] >= h0:
            hull.append([[-h, -h0], v, 1])
        else:
            hull.append([[h, h0], v, 1])
    return hull


def initial_points(dims):
    """
    Computes Initial set of Extreme Points
    """
    global RIDS
    num_vars = len(RIDS)
    h = [0] * num_vars
    h[dims[0]] = 1
    h = Matrix([h])
    # max
    opt = solve_lp_exact(h, -1, [], [])
    hx = h * opt
    eps = extreme_point(h, hx, -1, dims)
    # min
    opt = solve_lp_exact(h, 1, [], [])
    hx = h * opt
    ep = extreme_point(h, hx, 1, dims)
    # if extreme point already in the list of EPs
    if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
        eps = eps.col_insert(eps.shape[1], ep)
    while eps.shape[1] <= len(dims):
        [h, h0] = get_hyperplane(eps, dims)
        opt = solve_lp_exact(h, 1, [], [])
        hx = h * opt
        if hx[0] != h0:
            ep = extreme_point(h, hx, 1, dims)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
        else:
            opt = solve_lp_exact(h, -1, [], [])
            hx = h * opt
            ep = extreme_point(h, hx, -1, dims)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
    return eps


def create_lp(polyt, obj_inds):
    """ Creates core LP problem with the Stoichiometric Matrix and list of constraints"""
    # create problem
    p = qsoptex.ExactProblem()
    [Aeq, beq, rids, domain] = [polyt["Aeq"], polyt["beq"], polyt["rids"], polyt["domain"]]
    [lbs, ubs] = domain
    # add variables to lp
    for i in range(len(rids)):
        p.add_variable(name=rids[i], objective=Fraction(str(obj_inds[i])), lower=lbs[i], upper=ubs[i])
    # constraints
    # for each row in S (metabolite) = for each constraint
    for i in range(Aeq.shape[0]):
        constr = {}
        # for each column in S = for each reaction
        for j in range(Aeq.shape[1]):
            if Aeq[i, j] != 0:
                constr[rids[j]] = int(Aeq[i, j])
        p.add_linear_constraint(qsoptex.ConstraintSense.EQUAL, constr, rhs=int(beq[i]))
    return p


def read_problem(reactions_path, s_matrix_path, domains_path):
    """
    Read LP problem from 3 files: reactions, Stoichiometric matrix, and constraints
    """
    probl = {}
    # read reaction names
    reac_names = []
    infile = open(reactions_path, "r") # fname + "_r.txt"
    for line in infile.readlines():
        line = line.strip()
        reac_names.append(line)
    infile.close()
    probl["rids"] = reac_names
    # read upper and lower bounds of reactions (domain)
    lbs = []
    ubs = []
    infile = open(domains_path, "r") # fname + "_d.txt"
    for line in infile.readlines():
        line = line.strip()
        info = line.split()
        lbs.append(int(info[0]))
        ubs.append(int(info[1]))
    infile.close()
    probl["domain"] = [lbs, ubs]
    # read stoichiometric matrix. Rows=metabolites, columns=reactions
    S = []
    infile = open(s_matrix_path, "r") # fname + "_S.txt"
    for line in infile.readlines():
        line = line.strip()
        row = []
        for col in line.split():
            row.append(int(col))
        S.append(row)
    infile.close()
    beq = [0] * len(S)
    probl["Aeq"] = Matrix(S)
    probl["beq"] = Matrix(beq)

    return probl


def incremental_refinement(chull, eps, dims):
    """
    Refine initial convex hull is refined by maximizing/minimizing the \hps
    containing the \eps until all the facets of the projection are terminal.
    """
    while sum([chull[k][2] for k in range(len(chull))]) != 0:
        for i in range(len(chull)):
            if i >= len(chull):
                break
            h = chull[i][0][0]
            h0 = chull[i][0][1]
            opt = solve_lp_exact(h, -1, [], [])
            hx = h * opt
            if hx[0] == h0:
                chull[i][2] = 0
            else:
                ep = extreme_point(h, hx, -1, dims)
                if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                    eps = eps.col_insert(eps.shape[1], ep)
                    chull = update_CH(ep, eps, chull, dims)
        to_remove = []
        for i in range(len(chull)):
            ec = chull[i][0][0] * eps
            h0 = chull[i][0][1]
            if min(ec) < h0 and max(ec) > h0:
                to_remove.append(i)
        chull = [i for j, i in enumerate(chull) if j not in to_remove]
    return [chull, eps]


def update_CH(new_p, epts, chull, dims):
    """
    Given a new extreme point, compute all possible HP with the new EP
    """
    for i in range(len(chull)):
        pts = chull[i][1]
        if any([pts[dims, p] == new_p[dims, :] for p in range(pts.shape[1])]):
            continue
        bla = chull[i][0][0] * new_p
        if bla[0] <= chull[i][0][1]:
            continue
        for j in range(pts.shape[1]):
            v = pts[:, :]
            v[:, j] = new_p
            [h, h0] = get_hyperplane(v, dims)
            if hp_in_CH(h, h0, v, chull) or hp_in_CH(-h, -h0, v, chull):
                continue
            eh = h * epts
            if max(eh) <= h0:
                chull.append([[h, h0], v, 1])
            else:
                if min(eh) >= h0:
                    chull.append([[-h, -h0], v, 1])
    to_remove = []

    for i in range(len(chull)):
        ec = chull[i][0][0] * epts
        h0 = chull[i][0][1]
        if min(ec) < h0 and max(ec) > h0:
            to_remove.append(i)

    chull = [i for j, i in enumerate(chull) if j not in to_remove]

    return chull


def hp_in_CH(h, h0, v, chull):
    """this function checks if hyperplane and points are already in the CH"""
    flag = 0
    if any([[[h, h0], v] == chull[i][:-1] for i in range(len(chull))]):
        flag = 1
    return flag


# if __name__ == "__main__":
#     filename = sys.argv[1]
#     dims = sys.argv[2]
#     compute_CH(filename, map(int, dims.split(",")))

#+END_SRC
**** library dependency diagram
| Functions              | sympy | qsoptex | solve_lp_exact | get_hyperplane | extreme_point | update_CH | create_lp | read_problem | incremental_refinement | initial_points | initial_hull | hp_in_CH | compute_CH |
|------------------------+-------+---------+----------------+----------------+---------------+-----------+-----------+--------------+------------------------+----------------+--------------+----------+------------|
| sympy                  | X     |         |                |                |               |           |           |              |                        |                |              |          |            |
| qsoptex                |       | X       |                |                |               |           |           |              |                        |                |              |          |            |
| solve_lp_exact         | X     | X       | X              |                |               |           |           |              |                        |                |              |          |            |
| get_hyperplane         | X     |         |                | X              |               |           |           |              |                        |                |              |          |            |
| create_lp              | X     | X       |                |                |               |           | X         |              |                        |                |              |          |            |
| read_problem           | X     |         |                |                |               |           |           | X            |                        |                |              |          |            |
| hp_in_CH               |       |         |                |                |               |           |           |              |                        |                |              | X        |            |
| update_CH              | X     |         |                | X              |               | X         |           |              |                        |                |              |          |            |
| compute_CH             | X     | X       | X              | X              | X             | X         | X         | X            | X                      | X              | X            |          | X          |
| incremental_refinement | X     | X       | X              | X              | X             | X         |           |              | X                      |                |              |          |            |
| initial_points         | X     | X       | X              |                | X             |           |           |              |                        | X              |              |          |            |
| extreme_point          | X     | X       | X              |                | X             |           |           |              |                        |                |              |          |            |
| initial_hull           | X     |         |                |                |               |           |           |              |                        |                | X            |          |            |

** workon
*** TODO main program v2
    Adapted v1 to pylint's suggestions.
#+NAME: main_v2.py
#+BEGIN_SRC python :results output :tangle "./main_v2.py"
"""
Computes the convex hull for production envelopes of metabolic network. Solution is
the list of hyperplanes and set of extreme points of the Convex hull. Inputs are:
  - REACTION_FILE : absolute path to file containing one reaction name string in each line,
    the names must be aligned with the columns of the Stoichiometric matrix.
  - STOICHIOMETRIC_FILE : absolute path to file containing Stoichiometric matrix
  - DOMAIN_FILE : absolute path to file containing lower and upper bounds for each reaction,
    one pair in a line
  - INPUT_REACTIONS: list of indices for the dimensions onto which the CH should be computed
"""

import chm_exact_v2
# given information
REACTION_FILE = "/home/dherzig/ConvHull/DATA/toy/toy_reactions.txt"
STOICHIOMETRIC_FILE = "/home/dherzig/ConvHull/DATA/toy/toy_stoichs.txt"
DOMAIN_FILE = "/home/dherzig/ConvHull/DATA/toy/toy_domains.txt"
INPUT_REACTIONS = [0, 1]

# create dictionary from the above files for further processing
PROBLEM_READ = chm_exact_v2.read_problem(REACTION_FILE,
                                         STOICHIOMETRIC_FILE,
                                         DOMAIN_FILE)
# create some information for qsopt_ex (this makes a list of 3 zeros)
OBJ = [0] * PROBLEM_READ["Aeq"].shape[1]
# this sets the first zero to 1
OBJ[INPUT_REACTIONS[0]] = 1
# create linear problem from the dictionary to get rid off global statements within functions
PROBLEM_CREATED = chm_exact_v2.create_lp(PROBLEM_READ,
                                         OBJ)
# extract reaction ids, to get rid off the global statements within functions
REACTION_IDS = PROBLEM_READ["rids"]
CHULL, EPTS = chm_exact_v2.compute_CH(PROBLEM_READ,
                                      INPUT_REACTIONS,
                                      REACTION_IDS,
                                      PROBLEM_CREATED)
# refine results
REFINED_CHULL, REFINED_EPTS = chm_exact_v2.incremental_refinement(CHULL,
                                                                  EPTS,
                                                                  INPUT_REACTIONS,
                                                                  REACTION_IDS,
                                                                  PROBLEM_CREATED)
print("refined convex hull after refinement:")
print(REFINED_CHULL)
print("refined set of points:")
print(REFINED_EPTS)

#+END_SRC
*** TODO structural library analysis for speed tuning
**** independent functions
     The following functions partly depend on sympy and qsoptex, but do not depend on each other. 
***** docstring
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
""" library of functions for the exact convhull python algorithm"""
      #+END_SRC
***** dependencies
      #+begin_src python :tangle "./chm_exact_v2.py"
from fractions import Fraction
import os
import urllib
import sys
import xml.etree.ElementTree
import qsoptex
from sympy import Matrix, sympify
      #+end_src
     
***** download_model
      Function to retrieve model from the web.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def download_model(url):
    '''downloads existing model from the web, url has to be a string.
    returns absolute path of downloaded file as string.'''
    filename = url.split("/")[-1:][0]
    filepath = os.path.abspath(filename)
    with urllib.request.urlopen(url) as traveller:
        with open(filepath,"wb") as destination:
            destination.write(traveller.read())
    return filepath
      #+END_SRC
***** parse_xml_model
      Function to parse downloaded model and create reaction-file, stoichiometric matrix-file, and domain-file from it.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def parse_xml_model(model):
    '''parses existing xml model, given as path..
    if gunzipped, unzips automatically. returns xml.etree.ElementTree object'''
    if model.endswith("gz"):
        with gzip.open(model) as unpacked:
            tree = xml.etree.ElementTree.parse(unpacked)
            root = tree.getroot()
    else:
        tree = xml.etree.ElementTree.parse(model)
        root = tree.getroot()
    return root
      #+END_SRC
***** extract_parameters
      Function to extract all parameters from model and return them as list of tuples containing id and value.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def extract_parameters(model):
    '''takes a parsed model in xml.etree.ElementTree.parse-getroot format and returns
    a list of tuples containing id and value of the given parameters.'''
    parameter_list = []
    parameters_model = model.findall("{http://www.sbml.org/sbml/level3/version1/core}model/"
                                     "{http://www.sbml.org/sbml/level3/version1/core}listOfParameters/"
                                     "{http://www.sbml.org/sbml/level3/version1/core}parameter")
    for parameter in parameters_model:
        parameter_list.append((parameter.attrib["id"],parameter.attrib["value"]))
    return parameter_list
      #+END_SRC
***** extract_metabolites
      Function to extract all metabolites from model and return them as list of tuples containing name and ID.
      #+BEGIN_SRC python :tangle "./chm_exact_v2.py"
def extract_metabolites(model):
    '''takes a parsed model in xml.etree.ElementTree.parse-getroot format and returns
    a list of tuples containing id and name of the given metabolites.'''
    metabolite_list = []
    metabolites_model = model.findall("{http://www.sbml.org/sbml/level3/version1/core}model/"
                                      "{http://www.sbml.org/sbml/level3/version1/core}listOfSpecies/"
                                      "{http://www.sbml.org/sbml/level3/version1/core}species")
    for metabolite in metabolites_model:
        metabolite_list.append((metabolite.attrib["id"],metabolite.attrib["name"]))
    return metabolite_list
      #+END_SRC
***** extract_reactions
      Function to extract 
***** TODO solve_lp_exact
      + inputs (object-type) :: obj_inds (list), opt (?), h_add (?), h0_add (?)
      + outputs(object-type) :: Matrix(lp.get_values()) (sympy matrix)
      + depends (packages) :: sympy, qsoptex
      #+begin_src python :tangle "./chm_exact_v2.py"
def solve_lp_exact(obj_inds, opt, h_add, h0_add, reaction_ids, lp_prob):
    """
    Solves LP exactly
    """
    flag_a = 0
    # change objective
    new_obj = {}
    # set integers when possible to speed up computation
    for pos, value in enumerate(obj_inds):
        if sympify(obj_inds[pos]).is_integer or obj_inds[pos] == 0:
            new_obj[reaction_ids[pos]] = int(obj_inds[pos])
        elif sympify(obj_inds[pos]).is_rational:
            new_obj[reaction_ids[pos]] = Fraction(str(obj_inds[pos]))
    lp_prob.set_linear_objective(new_obj)
    # additional constraints other than stoichiometric, if any
    if h_add and h0_add:
        flag_a = 1
        constr = {}
        for pos,value in enumerate(h_add):
            if h_add[pos] != 0:
                if sympify(h_add[pos]).is_integer:
                    constr[reaction_ids[pos]] = int(h_add[pos])
                elif sympify(h_add[pos]).is_rational:
                    constr[reaction_ids[pos]] = Fraction(str(h_add[pos]))
        lp_prob.add_linear_constraint(qsoptex.ConstraintSense.EQUAL,
                                      constr,
                                      rhs=Fraction(str(h0_add[0])))
    if opt == -1:
        lp_prob.set_objective_sense(qsoptex.ObjectiveSense.MAXIMIZE)
    elif opt == 1:
        lp_prob.set_objective_sense(qsoptex.ObjectiveSense.MINIMIZE)
    else:
        sys.exit("opt takes 2 possible values: -1 or 1")
    lp_prob.set_param(qsoptex.Parameter.SIMPLEX_DISPLAY, 1)
    status = lp_prob.solve()
    # remove last constraint (if added) from the basis LP_PROB
    if flag_a:
        lp_prob.delete_linear_constraint(lp_prob.get_constraint_count() - 1)
    if status == qsoptex.SolutionStatus.OPTIMAL:
        return Matrix(lp_prob.get_values())
    else:
        sys.exit("Solver status is not optimal. Status:" + str(status))

       #+end_src
***** TODO get_hyperplane
      + inputs (object-type) :: pts (?), dims (?)
      + outputs (object-type) :: h(?), h0 (?)
      + depends (packages) :: sympy
      #+begin_src python :tangle "./chm_exact_v2.py"
def get_hyperplane(pts, dims):
    """
    Compute the Hessian Normal form of a set of points
    """
    h = Matrix.zeros(1, pts.shape[0])
    dis = -Matrix.ones(pts.shape[1], 1)
    pnts_dims = pts[dims, :].T
    C = pnts_dims.col_insert(pnts_dims.shape[1], dis)
    hess = C.nullspace()
    for i in range(len(dims)):
        h[dims[i]] = hess[0][i]
    h0 = hess[0][-1]
    return [h, h0]
      #+end_src
***** TODO create_lp
      + inputs (object-type) :: polyt (?), obj_inds (?)
      + outputs (object-type) :: p (?)
      + depends (packages) :: qsoptex, sympy
      #+begin_src python :tangle "./chm_exact_v2.py"
def create_lp(polyt, obj_inds):
    """ Creates core LP problem with the Stoichiometric Matrix and list of constraints"""
    # create problem
    p = qsoptex.ExactProblem()
    [Aeq, beq, rids, domain] = [polyt["Aeq"], polyt["beq"], polyt["rids"], polyt["domain"]]
    [lbs, ubs] = domain
    # add variables to lp
    for i in range(len(rids)):
        p.add_variable(name=rids[i],
                       objective=Fraction(str(obj_inds[i])),
                       lower=lbs[i],
                       upper=ubs[i])
    # constraints
    # for each row in S (metabolite) = for each constraint
    for i in range(Aeq.shape[0]):
        constr = {}
        # for each column in S = for each reaction
        for j in range(Aeq.shape[1]):
            if Aeq[i, j] != 0:
                constr[rids[j]] = int(Aeq[i, j])
        p.add_linear_constraint(qsoptex.ConstraintSense.EQUAL, constr, rhs=int(beq[i]))
    return p
      #+end_src
***** read_problem
      + inputs (object-type) :: reactions_path (textfile), s_matrix_path (textfile), domains_path (textfile)
      + outputs (object-type) :: probl (dict)
      + depends (packages) :: sympy
      #+begin_src python :tangle "./chm_exact_v2.py"
def read_problem(reactions_path, s_matrix_path, domains_path):
    """
    Read LP problem from 3 files: reactions, Stoichiometric matrix, and constraints
    """
    probl = {}
    # read reaction names
    reac_names = []
    with open(reactions_path, "r") as filetoberead:
        for line in filetoberead.readlines():
            line = line.strip()
            reac_names.append(line)
    probl["rids"] = reac_names
    # read upper and lower bounds of reactions (domain)
    lbs = []
    ubs = []
    with open(domains_path, "r") as filetoberead:
        for line in filetoberead.readlines():
            info = line.strip()
            info = line.split()
            lbs.append(int(info[0]))
            ubs.append(int(info[1]))
    probl["domain"] = [lbs, ubs]
    # read stoichiometric matrix. Rows=metabolites, columns=reactions
    S = []
    with open(s_matrix_path, "r") as filetoberead:
        for line in filetoberead.readlines():
            line = line.strip()
            row = []
            for column in line.split():
                row.append(int(column))
            S.append(row)
    beq = [0] * len(S)
    probl["Aeq"] = Matrix(S)
    probl["beq"] = Matrix(beq)
    return probl
      #+end_src
***** TODO hp_in_CH
      + inputs (object-type) :: h (?), h0 (?), v (?), chull (?)
      + outputs (object-type) :: flag (?)
      #+begin_src python :tangle "./chm_exact_v2.py"
def hp_in_CH(h, h0, v, chull):
    """this function checks if hyperplane and points are already in the CH"""
    flag = 0
    if any([[[h, h0], v] == chull[i][:-1] for i in range(len(chull))]):
        flag = 1
    return flag
      #+end_src
**** interdependent functions
     These functions partly depend on each other and/or the functions above.
***** TODO update_CH
      + inputs (object-type)  :: new_p (?), epts (?), chull (?), dims (?)
      + outputs (object-type) :: chull (?)
      + depends (return_object/return object type/self-depends) :: get_hyperplane(h,h0/??/sympy)
      #+begin_src python :tangle "./chm_exact_v2.py"
def update_CH(new_p, epts, chull, dims):
    """
    Given a new extreme point, compute all possible HP with the new EP
    """
    for i in range(len(chull)):
        pts = chull[i][1]
        if any([pts[dims, p] == new_p[dims, :] for p in range(pts.shape[1])]):
            continue
        bla = chull[i][0][0] * new_p
        if bla[0] <= chull[i][0][1]:
            continue
        for j in range(pts.shape[1]):
            v = pts[:, :]
            v[:, j] = new_p
            [h, h0] = get_hyperplane(v, dims)
            if hp_in_CH(h, h0, v, chull) or hp_in_CH(-h, -h0, v, chull):
                continue
            eh = h * epts
            if max(eh) <= h0:
                chull.append([[h, h0], v, 1])
            else:
                if min(eh) >= h0:
                    chull.append([[-h, -h0], v, 1])
    to_remove = []
    for i in range(len(chull)):
        ec = chull[i][0][0] * epts
        h0 = chull[i][0][1]
        if min(ec) < h0 and max(ec) > h0:
            to_remove.append(i)
    chull = [i for j, i in enumerate(chull) if j not in to_remove]
    return chull
      #+end_src

***** TODO compute_CH
      + inputs (object-type) :: reactions_path (textfile), s_matrix_path (textfile), domains_path (textfile), impt_reactions (list)
      + outputs (object-type) :: chull (dict), epts (sympy.Matrix)
      + depends (return object/return object type/self-depends) :: read_problem (probl/dict), create_lp (p/), initial_points (eps/sympy.Matrix/solve_lp_exact, extreme_point),initial_hull (hull/?/get_hyperplane), incremental_refinement (chull, eps/??/solve_lp_exact, extreme_points, update_CH)
      #+begin_src python :tangle "./chm_exact_v2.py" 
def compute_CH(lp_data, impt_reactions, reaction_ids, lp_prob):
    """
    Computes the convex hull for production envelopes of metabolic network. Solution is
    the list of hyperplanes and set of extreme points of the Convex hull. Inputs are:
      - lp_data: dictionary containing the keys 'rids', 'Aeq', 'beq'
      - fname_r.txt: list of reaction names - order must follow that of S columns
      - fname_S.txt: Stoichiometric matrix
      - fname_d.txt : lb ub for each reaction
    ,* impt_reactions: list of indices for the dimensions onto which the CH should be computed
    """
    # INITIAL POINTS
    epts = initial_points(impt_reactions, reaction_ids,lp_prob)
    # INITIAL HULL
    chull = initial_hull(epts, impt_reactions)
    return chull,epts
      #+end_src
***** TODO incremental_refinement
      + inputs (object-type) :: chull (dictionary), eps (?), dims (?)
      + outputs (object-type) :: chull (?), eps (?)
      + depends (return object/return object type/self-depends) :: solve_lp_exact (Matrix(lp.get_values())/sympy matrix/qsoptex,sympy), extreme_point (opt/?/solve_lp_exact), update_CH (chull/?/get_hyperplane)
      #+begin_src python :tangle "./chm_exact_v2.py"
def incremental_refinement(chull, eps, dims, reaction_ids, lp_prob):
    """
    Refine initial convex hull is refined by maximizing/minimizing the hps
    containing the eps until all the facets of the projection are terminal.
    """
    while sum([chull[k][2] for k in range(len(chull))]) != 0:
        for i in range(len(chull)):
            if i >= len(chull):
                break
            h = chull[i][0][0]
            h0 = chull[i][0][1]
            opt = solve_lp_exact(h, -1, [], [], reaction_ids, lp_prob)
            hx = h * opt
            if hx[0] == h0:
                chull[i][2] = 0
            else:
                ep = extreme_point(h, hx, -1, dims, reaction_ids, lp_prob)
                if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                    eps = eps.col_insert(eps.shape[1], ep)
                    chull = update_CH(ep, eps, chull, dims)
        to_remove = []
        for i in range(len(chull)):
            ec = chull[i][0][0] * eps
            h0 = chull[i][0][1]
            if min(ec) < h0 and max(ec) > h0:
                to_remove.append(i)
        chull = [i for j, i in enumerate(chull) if j not in to_remove]
    return chull, eps
      #+end_src
***** TODO initial_points
      + inputs (object-type) :: dims
      + outputs (object-type) :: eps
      + depends (return object/return object type/self-depends) :: solve_lp_exact (Matrix(lp.get_values())/sympy matrix/qsoptex,sympy), extreme_point (opt/?/solve_lp_exact)
      #+begin_src python :tangle "./chm_exact_v2.py"
def initial_points(dims,reaction_ids, lp_prob): # depends on solve_lp_exact and extreme_point
    """
    Computes Initial set of Extreme Points
    """
    h = [0] * len(reaction_ids)
    h[dims[0]] = 1
    h = Matrix([h])
    # max
    opt = solve_lp_exact(h, -1, [], [], reaction_ids, lp_prob)
    hx = h * opt
    eps = extreme_point(h, hx, -1, dims, reaction_ids, lp_prob)
    # min
    opt = solve_lp_exact(h, 1, [], [], reaction_ids, lp_prob)
    hx = h * opt
    ep = extreme_point(h, hx, 1, dims, reaction_ids, lp_prob)
    # if extreme point already in the list of EPs
    if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
        eps = eps.col_insert(eps.shape[1], ep)
    while eps.shape[1] <= len(dims):
        [h, h0] = get_hyperplane(eps, dims)
        opt = solve_lp_exact(h, 1, [], [], reaction_ids, lp_prob)
        hx = h * opt
        if hx[0] != h0:
            ep = extreme_point(h, hx, 1, dims, reaction_ids, lp_prob)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
        else:
            opt = solve_lp_exact(h, -1, [], [])
            hx = h * opt
            ep = extreme_point(h, hx, -1, dims, reaction_ids, lp_prob)
            if not any([eps[dims, j] == ep[dims, :] for j in range(eps.shape[1])]):
                eps = eps.col_insert(eps.shape[1], ep)
    return eps
      #+end_src
***** TODO extreme_point
      + inputs (object-type) :: h (?) , h0 (?), optim (?), dims (?)
      + outputs (object-type) :: opt (?)
      + depends (return object/return object type/self-depends) :: solve_lp_exact (Matrix(lp.get_values())/sympy matrix/qsoptex,sympy)
      #+begin_src python :tangle "./chm_exact_v2.py"
def extreme_point(h, h0, optim, dims, reaction_ids, lp_prob): # depends on solve_lp_exact
    """
    Computes the extreme point of the projection
    """
    obj = [0] * len(h)
    for i in range(len(dims)):
        obj[dims[i]] = 1
    opt = solve_lp_exact(obj, optim, h, h0, reaction_ids, lp_prob)
    return opt
      #+end_src
***** TODO initial_hull
      + inputs (object-type) :: pnts (?), dims (?)
      + outputs (object-type) :: hull (?)
      + depends (return object/return object type/self-depends) :: get_hyperplane (h,h0/??/sympy)
      #+begin_src python :tangle "./chm_exact_v2.py"
def initial_hull(pnts, dims): # depends on get_hyperplane
    """
    Computes initial hull for the initial set of extreme points
    """
    hull = []
    for i in range(pnts.shape[1]):
        v = pnts[:, :]
        v.col_del(i)
        [h, h0] = get_hyperplane(v, dims)
        if (h * pnts[:, i])[0] >= h0:
            hull.append([[-h, -h0], v, 1])
        else:
            hull.append([[h, h0], v, 1])
    return hull
      #+end_src
